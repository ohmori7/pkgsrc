$NetBSD: patch-CVE-2017-11613,v 1.1.2.2 2018/10/29 14:49:32 bsiegert Exp $

patch for CVE-2017-11613 taken from upstream git repo

--- libtiff/tif_dirread.c.orig	2017-09-16 19:07:56.000000000 +0000
+++ libtiff/tif_dirread.c
@@ -167,6 +167,7 @@ static int TIFFFetchStripThing(TIFF* tif
 static int TIFFFetchSubjectDistance(TIFF*, TIFFDirEntry*);
 static void ChopUpSingleUncompressedStrip(TIFF*);
 static uint64 TIFFReadUInt64(const uint8 *value);
+static int _TIFFGetMaxColorChannels(uint16 photometric);
 
 static int _TIFFFillStrilesInternal( TIFF *tif, int loadStripByteCount );
 
@@ -3507,6 +3508,35 @@ static void TIFFReadDirEntryOutputErr(TI
 }
 
 /*
+ * Return the maximum number of color channels specified for a given photometric
+ * type. 0 is returned if photometric type isn't supported or no default value
+ * is defined by the specification.
+ */
+static int _TIFFGetMaxColorChannels( uint16 photometric )
+{
+    switch (photometric) {
+	case PHOTOMETRIC_PALETTE:
+	case PHOTOMETRIC_MINISWHITE:
+	case PHOTOMETRIC_MINISBLACK:
+	    return 1;
+	case PHOTOMETRIC_YCBCR:
+	case PHOTOMETRIC_RGB:
+	case PHOTOMETRIC_CIELAB:
+	    return 3;
+	case PHOTOMETRIC_SEPARATED:
+	case PHOTOMETRIC_MASK:
+	    return 4;
+	case PHOTOMETRIC_LOGL:
+	case PHOTOMETRIC_LOGLUV:
+	case PHOTOMETRIC_CFA:
+	case PHOTOMETRIC_ITULAB:
+	case PHOTOMETRIC_ICCLAB:
+	default:
+	    return 0;
+    }
+}
+	
+/*
  * Read the next TIFF directory from a file and convert it to the internal
  * format. We read directories sequentially.
  */
@@ -3522,6 +3552,7 @@ TIFFReadDirectory(TIFF* tif)
 	uint32 fii=FAILED_FII;
         toff_t nextdiroff;
     int bitspersample_read = FALSE;
+	int color_channels;
 
 	tif->tif_diroff=tif->tif_nextdiroff;
 	if (!TIFFCheckDirOffset(tif,tif->tif_nextdiroff))
@@ -4026,6 +4057,37 @@ TIFFReadDirectory(TIFF* tif)
 			}
 		}
 	}
+
+	/*
+	 * Make sure all non-color channels are extrasamples.
+	 * If it's not the case, define them as such.
+	 */
+	color_channels = _TIFFGetMaxColorChannels(tif->tif_dir.td_photometric);
+	if (color_channels && tif->tif_dir.td_samplesperpixel - tif->tif_dir.td_extrasamples > color_channels) {
+		uint16 old_extrasamples;
+		uint16 *new_sampleinfo;
+
+		TIFFWarningExt(tif->tif_clientdata,module, "Sum of Photometric type-related "
+		    "color channels and ExtraSamples doesn't match SamplesPerPixel. "
+		    "Defining non-color channels as ExtraSamples.");
+
+		old_extrasamples = tif->tif_dir.td_extrasamples;
+		tif->tif_dir.td_extrasamples = (tif->tif_dir.td_samplesperpixel - color_channels);
+
+		// sampleinfo should contain information relative to these new extra samples
+		new_sampleinfo = (uint16*) _TIFFcalloc(tif->tif_dir.td_extrasamples, sizeof(uint16));
+		if (!new_sampleinfo) {
+		    TIFFErrorExt(tif->tif_clientdata, module, "Failed to allocate memory for "
+				"temporary new sampleinfo array (%d 16 bit elements)",
+				tif->tif_dir.td_extrasamples);
+		    goto bad;
+		}
+
+		memcpy(new_sampleinfo, tif->tif_dir.td_sampleinfo, old_extrasamples * sizeof(uint16));
+		_TIFFsetShortArray(&tif->tif_dir.td_sampleinfo, new_sampleinfo, tif->tif_dir.td_extrasamples);
+		_TIFFfree(new_sampleinfo);
+	}
+
 	/*
 	 * Verify Palette image has a Colormap.
 	 */
@@ -5698,6 +5760,16 @@ ChopUpSingleUncompressedStrip(TIFF* tif)
         if( nstrips == 0 )
             return;
 
+        /* If we are going to allocate a lot of memory, make sure that the */
+	/* file is as big as needed */
+	if( tif->tif_mode == O_RDONLY &&
+	    nstrips > 1000000 &&
+	    (offset >= TIFFGetFileSize(tif) ||
+	     stripbytes > (TIFFGetFileSize(tif) - offset) / (nstrips - 1)) )
+	{
+	    return;
+	}
+
 	newcounts = (uint64*) _TIFFCheckMalloc(tif, nstrips, sizeof (uint64),
 				"for chopped \"StripByteCounts\" array");
 	newoffsets = (uint64*) _TIFFCheckMalloc(tif, nstrips, sizeof (uint64),
